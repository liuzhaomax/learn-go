# 数据库

<!-- TOC -->
* [数据库](#数据库)
  * [一条SQL查询语句执行顺序](#一条sql查询语句执行顺序)
  * [一条SQL更新语句执行顺序](#一条sql更新语句执行顺序)
  * [事务的隔离级别，怎么选](#事务的隔离级别怎么选)
  * [索引](#索引)
  * [索引的分类](#索引的分类)
  * [索引的操作](#索引的操作)
  * [锁](#锁)
  * [Join优化](#join优化)
  * [怎样避免写出慢SQL](#怎样避免写出慢sql)
  * [集群](#集群)
    * [备库延迟很长怎么排查](#备库延迟很长怎么排查)
  * [异构数据同步](#异构数据同步)
  * [如何将“删库跑路”的损失降到最低](#如何将删库跑路的损失降到最低)
  * [数据越来越多，数据库越来越慢该怎么办](#数据越来越多数据库越来越慢该怎么办)
  * [禁用外键](#禁用外键)
  * [为什么MongoDB用B树，MySQL用B+树](#为什么mongodb用b树mysql用b树)
<!-- TOC -->

---

## 一条SQL查询语句执行顺序
1. from
2. join
3. on
4. where
5. group by
6. avg, sum ...
7. having
8. select
9. distinct
10. order by
11. limit

## 一条SQL更新语句执行顺序
1. 首先执行器根据StudentID=1的索引取得这一行数据，如果这一行数据在内存中，就直接返回给执行器，否者从磁盘读取进内存再返回。
2. 执行器拿到数据给name改为小明，得到新的数据行。
3. 引擎将这个数据更新到内存中，然后将操作记录写入redo log，这时redo log处于prepare状态，然后告知执行器已经完成可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写进磁盘。
5. 执行器调用引擎接口提交事务，并把刚刚写入的redo log 改成提交（commit）状态，更新完成

## 事务的隔离级别，怎么选
事务的四大特性分别是：原子性、一致性、隔离性、持久性

事务的隔离级别：
1. **Read uncommitted（读未提交）** 解决了更新丢失。
   一个写，另一个不许写，但是可以读，会出现脏读，即读了没提交的脏数据。
2. **Read committed（读提交）** 一个写，另一个不许读，解决了脏读。
   一个读，允许其他读写，出现不可重复读，即A读了alpha，B写成beta，A再读就变成了beta。
3. **Repeatable read（可重复读取）** 一个读，允许其他读，不许写，写的时候禁止访问，解决了不可重复读。
   出现幻读，即A读出数据后，B删除数据，A就读出了不存在的数据。这个目前由后端报异常后，再次请求进行避免。
4. **Serializable（可序化）** 不允许事务并发，解决了幻读，但是性能太低。

**1. 第一种隔离级别：Read uncommitted(读未提交)**

如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据，该隔离级别可以通过“排他写锁”，但是不排斥读线程实现。这样就避免了更新丢失，却可能出现脏读，也就是说事务B读取到了事务A未提交的数据

解决了更新丢失，但还是可能会出现脏读

**2. 第二种隔离级别：Read committed(读提交)**

如果是一个读事务(线程)，则允许其他事务读写，如果是写事务将会禁止其他事务访问该行数据，该隔离级别避免了脏读，但是可能出现不可重复读。事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。

解决了更新丢失和脏读问题

语句级的readview，一个select生成一个readview

**3. 第三种隔离级别：Repeatable read(可重复读取)**

可重复读取是指在一个事务内，多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的，因此称为是可重复读隔离级别，读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务(包括了读写)，这样避免了不可重复读和脏读，但是有时可能会出现幻读，即A读出数据后，B删除数据，A就读出了不存在的数据。(读取数据的事务)可以通过“共享读镜”和“排他写锁”实现。

解决了更新丢失、脏读、不可重复读、但是还会出现幻读

事务级的readview，一个事务生成一个readview

**4. 第四种隔离级别：Serializable(可序化)**

提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行，如果仅仅通过“行级锁”是无法实现序列化的，必须通过其他机制保证新插入的数据不会被执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也是最高的，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读

解决了更新丢失、脏读、不可重复读、幻读(虚读)

## 索引
mysql5.8以后是 InnoDB，B+树索引，加入行锁，加入事务，聚簇索引（数据和索引是一个文件），存储空间小，通过辅助索引找主键速度快，找其他字段速度慢

mysql5.8以前是 MyISAM，B+树索引，不支持事务，表锁，不支持外键，非聚簇索引（数据和索引分开储存），存储空间大

B+树解决了B树回旋查找的问题

**索引失效**

> 模型数空运最快
+ 模：模糊查询 like %xx
+ 型：数据类型错误
+ 数：函数运算 sum() round()
+ 空：索引没有加约束 not null
+ 运：对索引进行运算 + - * / != <> is null, is not null, or
+ 最：最佳左前缀法则 联合索引先查左边
+ 快：全表查询比索引查询快的时候

## 索引的分类
+ 主键索引：primary key
+ 唯一索引：unique
+ 普通索引：就很普通，受控于数据库，也不唯一
+ 全文索引：针对关键字进行搜索，每个表只有一个

两个字段作为一个索引是复合索引。

InnoDB是聚簇索引，数据与索引存在一个B+树里，存储空间小，通过辅助索引找主键速度快，找其他字段速度慢，因为他要先找到主键。<br/>
MyISAM是非聚簇索引，数据与索引分开，存储空间大。

InnoDB使用B+树作为底层数据结构，B+树的链表解决了回旋查找问题。

## 索引的操作
查看
```sql
show index from user;
```
主键索引，可在创建表时，标记`primary key`在字段后面。主键必须唯一，可以是联合索引做主键。
```sql
alter table user drop primary key;
alter table user;
add primary key (user_email);
```
唯一索引，同主键索引，关键字为 `unique`
```sql
create unique index uq_index_user_email on user(user_email);
drop index uq_index_user_email;
alter table user;
add unique key (user_email);
```
普通索引
```sql
create index index_user_email on user(user_email);
drop index index_user_email;
```
全文索引
```sql
create fulltext index on user;
key index f_index_user;
drop fulltext index on user;
```

## 锁
+ 共享锁：查
+ 排他锁：增删改
+ 全局锁
+ 表锁
+ 间隙锁：InnoDB加入，解决了RR级别使用MVCC产生的幻读问题
+ 行锁
+ MVCC（Multi-Version Concurrent Control）：RC和RR的快照读的底层实现原理（比如select），读写的时候不会竞争锁，提高性能。当前读用锁。

## Join优化
+ 关联字段添加索引
+ 小表做驱动表：小表 join 大表 on ...
+ 临时表

## 怎样避免写出慢SQL
+ 估算数据量
+ 使用索引
+ 优化SQL，避免三表join等
+ 使用慢查询日志排查
+ 使用explain，分析SQL执行计划

## 集群
主从备份

MHA架构：主挂了，从顶上。提高可用性
+ 故障排查：MHA manager 对主节点3秒1ping，3次ping不到就联系从服务器去ping，从也连不上就确认故障。
+ 故障转移（几秒钟）：
   + 虚拟IP与主服务器断开连接，主从同步断开
   + manager抽取binlog server上的binlog，存入MHA服务器
   + 从属服务器进行比对，看谁是最新的，确定最新的
   + 最新数据的从节点去同步其他从节点
   + 旧的主节点（binlog）与所有从节点进行同步
   + 将某个从节点提升为主节点，三种方式：
     + 指定
     + 看哪个slave的log是最新的
     + 按注册实例列表向后选择一个
   + 其他从节点用change master语句连接到新的主节点
   + 虚拟IP飘移到新的主节点
   + 旧主修复好后会降级为从服务器进行同步
+ 优点
   + perl语言开源工具
   + 可支持基于GTID的复制模式
   + 当主DB不可用，从从DB中选新主
   + 主从切换，故障在线转移，不易丢失数据
   + 同一个监控节点可以监控多个集群
+ 缺点
   + 需要编写脚本或者第三方提供虚拟IP配置
   + MHA启动后只ping主节点，不能监控从节点，某从节点宕机，主节点再宕的时候，会出现故障迁移失败
   + 需要基于SSH免认证登陆配置，存在安全隐患，需要外部安全机制
   + 没有提供从服务器的读负载均衡功能

分片：range，hash

读写分离，通常写操作主，读采用负载均衡的方式操作从

适合十亿级别数据量，百亿千亿采用大数据方式

主流MySQL集群架构（应对高并发）：

应用 - 分片中间件 - 主分片1 - （从分片1 + 从分片1 + ...）

~~应用 - 分片中间件~~ - 主分片2 - （从分片2 + 从分片2 + ...）

### 备库延迟很长怎么排查
+ 看TPS是否大幅上涨
+ 审计日志
+ 对只读实例排查，查看其负载压力是否过大
+ 用explain操作查看是否有锁等待
+ 判断大查询并kill

## 异构数据同步
MySQL与ElasticSearch数据结构不同

A去同步B，调用B的接口，会产生强耦合（A需要知道B接口的功能）。

阿里巴巴 Canal 中间件：监听relaylog，自动触发Java代码向ES同步。解决监听问题。监听binlog可以同时利用MQ更新缓存。

MQ（解决耦合问题）

A有新数据 - Canal监听到 - 传入MQ - 其他已订阅MQ的应用

## 如何将“删库跑路”的损失降到最低
+ 全量备份
+ Binlog备份
+ 数据库不要在同一个服务器上，越远越好
+ 在回放 binlog的时候，指定的起始时间可以比全量备份的时间稍微提前一点，确保全量备份之后的所有操作都在恢复的 binlog范围内，这样可以保证恢复的数据的完整性。
+ 开启同步复制，MySQL主库会等待数据成功复制到从库之后，再给客户端响应。

## 数据越来越多，数据库越来越慢该怎么办
+ 读写分离，主从复制
+ 归档历史数据
+ 分库分表：水平分库分表（根据range和hash），垂直分库分表（根据业务和字段活跃度）

## 禁用外键
+ 性能问题：会检查主外键是否一致，造成性能降低
+ 并发问题：外键约束查询校验主键一致性时，会启用行级共享锁，主表写入时，会将数据变为行级排他锁，则查询会造成阻塞
+ 级联删除：会让数据变得不可控，触发器也严格被禁用
+ 耦合问题：数据关系产生耦合，数据迁移困难

## 为什么MongoDB用B树，MySQL用B+树
因为MongoDB是文档结构，不需要经常遍历，回旋查找不多，不需要B+树