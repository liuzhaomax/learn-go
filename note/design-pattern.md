# Design Pattern

>鸣谢大佬 欢喜（B站：面向加薪学习）

1. 单例
2. 观察者
3. 组合
4. 策略
5. 装饰器
6. 状态
7. 代理
8. 适配器
9. 工厂
10. 抽象工厂
11. 外观
12. 建造者
13. 桥接
14. 命令
15. 迭代器
16. 模板
17. 访问者
18. 备忘录
19. 责任链
20. 中介
21. 原型
22. 享元
23. 解释器

---

## 1. 单例模式

**定义**：某结构体只有一个对象

**实现**：利用sync.Once的Do方法创建对象，使用函数方式获取此对象

**场景**：定义上下文对象

## 2. 观察者模式

**定义**：主体发布消息（事件）后，注册过的观察者会执行某事，同时会读取所发布消息的内容

**实现**：主体持有观察者的列表和对列表元素修改的方法（注册方法），观察者持有针对事件的执行方法，其参数是事件，主体调用通知函数时，会遍历其观察者列表，各个观察者调用其执行事件的方法，并将事件作为参数传入。

**场景**：事件驱动模型，监听数据，双向绑定

## 3. 组合模式

**定义**：组合体执行方法，其各个组合个体都会调用同名的方法

**实现**：某组件持有其他组件形成list，形成组合体，定义同样的接口，实现接口时遍历list并执行接口函数。

**场景**：树形结构中各节点统一执行

## 4. 策略模式

**定义**：让对象执行不同的操作

**实现**：对象可set不同策略对象，对象执行方法时，先引用传入的策略对象，再执行策略对象的方法，策略对象的方法的参数可由主对象执行方法传入。

**场景**：if情况过多（例如：商家有多种促销方式）

## 5. 装饰器模式

**定义**：包装函数A，在包装袋里调用其他函数B，使执行A时执行B

**实现**：利用闭包，定义一个包裹函数C（参数是被包裹的函数名A和持有函数B的对象Obj），返回函数D（参数是A的参数，返回值是A的返回值），在D内部定义函数E（参数是A的参数，返回值是A的返回值），函数E内部会执行A和Obj的某个方法，可通过defer调整执行顺序（如果没有返回值可以不使用defer），让函数B在A调用前或后执行。在函数D内部执行E。由于D被C返回给主程序某变量，所以在D没有执行前，E不会被执行。当执行被C返回的D时，E被D在内部调用，从而使AB在E中被执行。

```go
func WrapLogger(fun PiFunc, logger *log.Logger) PiFunc {   //C
	return func(n int) float64 {  //D
		fn := func(n int) (result float64) {  //E
			defer func(t time.Time) {
				logger.Printf("took=%v, n=%v, result=%v", time.Since(t), n, result) //Obj的B
			}(time.Now())
			return fun(n) //A
		}
		return fn(n)
	}
}
```
```go
foo := WrapLogger(Pi, log.New(os.Stdout, "test", 1))
foo(10000)
```

**场景**：AOP，日志

## 6. 状态模式