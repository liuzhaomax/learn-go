# 分布式系统

## 1. Raft算法

### 1.1 算法概述

Raft算法是一种用于分布式系统中的共识算法，旨在实现可靠的分布式一致性。Raft通过让多个节点之间就日志条目的顺序达成一致，
从而确保系统中的所有节点都能保持相同的状态。这在实现容错和高可用性方面非常重要。Raft算法被设计成易于理解和实现的替代方案，相比于Paxos，它更加直观。

**Raft算法的基本概念**

Raft将共识问题分解为三个相对独立的子问题：

+ 领导选举（Leader Election）：在系统启动或现有领导者失效时，选举出一个新的领导者。
+ 日志复制（Log Replication）：由领导者将客户端的请求记录到日志，并复制到所有从节点（Followers）。
+ 安全性（Safety）：确保系统的一致性，即所有节点最终都能达成一致的状态。

**角色和状态**

Raft中的节点可以扮演三种角色：

+ 领导者（Leader）：处理所有客户端请求，并负责日志的复制。
+ 候选者（Candidate）：在选举期间试图成为领导者。
+ 追随者（Follower）：被动接收和复制来自领导者的日志条目。

**操作流程**
1. 领导选举
   
领导选举在以下情况下触发：

+ 系统初始化时，没有领导者。
+ 当前领导者失效（心跳超时）。

选举过程：

+ 当追随者超过选举超时时间没有收到领导者的心跳时，会转换为候选者并开始选举。
+ 候选者增加当前任期号，并向其他所有节点发送请求投票（RequestVote）消息。
+ 其他节点在没有投票的情况下，收到请求投票消息时会给候选者投票。
+ 一旦候选者获得多数节点的投票，就成为新的领导者。

2. 日志复制

一旦领导者被选出，日志复制过程开始：

+ 客户端请求被发送到领导者，领导者将请求作为新的日志条目添加到自己的日志中。
+ 领导者将新的日志条目通过追加条目（AppendEntries）消息发送给追随者。
+ 追随者收到新的日志条目后，追加到自己的日志中并回复确认。
+ 一旦日志条目在多数节点上被复制，领导者将条目标记为已提交，并应用到状态机中，同时通知追随者应用已提交的日志条目。

4. 安全性
   
Raft通过以下机制保证一致性：

+ 任期（Term）：每个任期编号唯一且递增，用于区分不同的领导者选举周期。
+ 领导者的日志完整性：只有拥有最新日志的候选者才能赢得选举。
+ 日志匹配属性：如果两个日志在相同的索引位置和任期上都有相同的条目，那么这两个日志之前的所有条目都是相同的。

**Raft的特性**

+ 简明性：Raft被设计为一种更容易理解和实现的算法。
+ 一致性：通过选举和日志复制机制，保证所有节点最终达到一致的状态。
+ 高可用性：即使部分节点失效，系统仍然能继续提供服务，只要多数节点可用。

**Raft的实现**

主要数据结构
+ 日志条目（Log Entry）：包含命令和任期编号。
+ 状态机：应用日志条目的地方，决定系统的实际行为。
+ 持久化状态：节点的当前任期和日志条目，需要在节点崩溃后恢复。

消息类型
+ 请求投票（RequestVote）：用于选举领导者。
+ 追加条目（AppendEntries）：用于日志复制和心跳。

Raft算法以其易于理解和实现的特点在分布式系统中广泛应用。
通过确保选举领导者、复制日志条目和维护一致性，它为实现容错和高可用性提供了坚实基础。

### 1.2 投票过程

**详细步骤**

选举超时和候选者状态转换：

如果一个追随者节点在选举超时时间内没有收到当前领导者的心跳（AppendEntries 消息），它会将自己的状态转换为候选者，并开始一个新的选举周期（term）。

1. 发起投票请求：

+ 候选者将当前任期号加1，并将自己的投票数初始化为1（为自己投票）。
+ 候选者向集群中的所有其他节点发送 RequestVote 请求，包含以下信息：
+ 候选者的任期号（currentTerm）
+ 候选者的日志索引（lastLogIndex）和日志条目的任期号（lastLogTerm），用于表明候选者日志的最新状态。

2. 节点接收投票请求：

+ 接收到 RequestVote 请求的节点将进行以下判断：
+ 如果请求中的任期号小于该节点的当前任期号，则拒绝投票。
+ 如果该节点没有投票或者已经投票给了当前任期内的其他候选者，则进行进一步的日志检查：
+ 比较候选者的日志是否比自己更新。如果候选者的日志比接收节点的日志更“新”（任期号更大，或者在任期号相同时，日志索引更大），则接收节点投票给候选者。

3. 候选者收集投票：

+ 候选者等待来自其他节点的投票回复。如果收到过半数（多数）节点的投票（包括自己的投票），则成为新的领导者。
+ 如果在等待过程中，有其他候选者或领导者发送了更高任期的消息，候选者将转换为追随者状态，并更新自己的任期号。

4. 领导者发送心跳信号：

+ 新领导者开始任职后，会立即向所有其他节点发送心跳（AppendEntries 请求，带有空日志条目）以确认领导者身份，并阻止新的选举周期开始。

**投票过程中涉及的条件和判断**

任期号：

+ 投票时首先比较请求中的任期号和自身的当前任期号。较小的任期号表示过时，直接拒绝。
+ 如果候选者的任期号较大，接收节点会更新自己的任期号并转换为追随者状态。

日志的新旧判断：

+ 日志比较首先看任期号，任期号大的日志更新。
+ 如果任期号相同，则比较日志索引，索引大的日志更新。

**投票示例**

假设有5个节点A、B、C、D、E，节点A超时没有收到领导者的心跳，开始选举：

+ 节点A转换为候选者，增加任期号并自增投票数。
+ 节点A向B、C、D、E发送 RequestVote 请求。
+ 节点B、C、D、E接收到请求，比较任期号和日志情况：
  + 如果B、C、D、E都同意并投票，A将收到至少3个投票，成为领导者。
+ A成为领导者后，立即发送心跳信号，维持领导者身份，防止其他节点发起新的选举。

通过上述步骤，Raft算法确保选举过程的可靠性和一致性，使得在分布式系统中能够快速而有效地选举出一个新的领导者，从而保持系统的高可用性和一致性。


## 2. CAP理论

CAP理论（CAP Theorem）是计算机科学中的一个基本定理，用于描述分布式数据存储系统中的一致性、可用性和分区容忍性三者之间的权衡。
CAP理论表明，在分布式系统中，不可能同时完全满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）这三个特性。
具体来说，分布式系统只能在这三个特性中同时满足两个，无法同时完全满足所有三个特性。

场景举例：
+ CP：金融、订单、交易系统
+ AP：社交网络、内容分发网络


## 3. 分布式事务

> https://www.bilibili.com/list/watchlater?bvid=BV1Du4y1L7L4&oid=918643831

### 3.1 2PC

2PC 3PC都是强一致性，TCC SAGA MQ是最终一致性

具有事务协调者，和事务参与者

2阶段：

+ 准备/提交 
+ 准备/回滚

特点：

+ 强一致性
+ 事务阻塞

### 3.2 3PC

多了一个 canCommit?

### 3.3 TCC

Try Confirm Cancel

特点：

+ 类似2PC
+ 阻塞粒度小

阶段：

1. try阶段：协调者问参与者，“先试试行不行？不行再说”，用来排除导致事务失败的可能性，例如库存为0，无效数据等
2. confirm阶段：协调者问参与者，“既然你已经准备好了，那就开始搞”
3. cancel阶段：协调者发现，或参与者告知有异常，“取消”

### 3.4 SAGA

流水线事务，分割成小事务

特点：
+ 场景：事务过程很长
+ 不要求隔离性（一个去操作库存，另一个也可以去操作）
+ 减少阻塞时间

### 3.5 MQ

1. 生产者发送预备消息（半消息）“我开始了”
2. MQ 预备消息确定 
3. 生产者开始业务逻辑操作
4. 生产者发送提交消息
5. MQ 投递消息
6. 消费者开始操作处理消息

生产者故障，MQ会发删除预备消息给生产者

消费者故障，消费者会要求重试，直到成功，重试默认16次，全失败，说明业务代码问题，人工干预
